package Dancer2::Tutorial;
# ABSTRACT: An example to get you dancing

=pod

=head1 What is Dancer2?

Dancer2 is a "micro" web framework which is modeled after a Ruby framework
called L<Sinatra|http://www.sinatrarb.com> that constructs web applications
by building a list of HTTP verbs, URLs (called routes) and methods to handle
that type of traffic to that specific URL.

  use Dancer2;

  get '/' => sub {
    return 'Hello World!';
  };

  start;

This example shows a single HTTP verb "GET" followed by the root URL "/" and
an anonymous subroutine which returns the string C<"Hello World!">  If you
were to run this example, it would display "Hello World!" when you point
your browser at L<http://localhost:3000>.

=head1 How about a more involved example?

Simple examples - although able to quickly show off essential features -
don't often give the user enough material in order to create a basic,
nevertheless full-fledged application. That's the reason for this tutorial.
Web frameworks such as L<Flask|http://flask.pocoo.org/> or
L<Bottle|http://bottle.paws.de/docs/dev/index.html> examine nicely in a
step-by-step manner how to build a basic application which is more involved
than a trivial example.

In this tutorial we'll build a sample "micro" blog application, based
heavily on the sample application
L<Flaskr|http://github.com/mitsuhiko/flask/tree/master/examples/flaskr/>,
however instead of using Flask to build I<Flaskr>, we'll use Dancer2 to
build I<Dancr>.

=head1 Required software

To follow along with this tutorial we're going to need some supporting
software. Also, we're going to assume a (Debian) Linux system. If you're on
another version of Linux, another version of Unix, or even on MacOSX or
Windows, hopefully you'll be able to follow along ok.

=head2 Git

One of the most important tools in any software project is a version control
system, and here we're going to be using L<Git|http://git-scm.com/>. For a
great introduction to Git - and for details about its usage - the
L<Git-book|http://git-scm.com/book/> by Scott Chacon is highly recommended.
One can of course download and build Git from source, but it's much easier
to simply install the relevant package:

    $ sudo aptitude install git

=head2 Sqlite

Our micro blog will need a database engine to store blog entries and for
this purpose we choose L<SQLite|http://www.sqlite.org> for its simplicity
and small resource requirements.

    $ sudo aptitude install sqlite

=head2 Perl software and modules

=head3 perlbrew

The Debian system Perl maintainers have been doing a sterling job recently
of keeping up with Perl development and thus if you're using Debian, the
Perl version which came with your distribution is likely the most recent
stable release. However, if you're not so lucky and you wish to use a recent
Perl, you can install L<perlbrew|http://perlbrew.pl/> and build your own.
Another advantage of C<perlbrew> is that you can install Perl modules in
your home directory without having to ask your system administrator to
install them, or (if you are the admin) without having to "pollute" the
module namespace in your system directories. Because it is such and
advantage that we can install our own modules without influencing other
users on the system, we'll install C<perlbrew> and our very own version of
Perl. This will take a while, but be patient! It's worth it!

First install C<perlbrew>

    $ sudo aptitude install perlbrew

Initialize C<perlbrew> with its C<init> command (you only need to do this
once):

    $ perlbrew init

A C<perl5/> directory will now have been created in your home directory, and
it is within this directory structure that the our new Perl version (and its
modules) will be installed. We can see which Perls are available with
C<perlbrew>'s C<available> command:

    $ perlbrew available
    ... more output ...

Let's select C<perl-5.20.1> (current Perl stable version as of writing) and
install that:

    $ perlbrew install perl-5.20.1

And now wait a while until Perl is installed. You can follow along with the
progress of the installation and test process by using the C<tail> command
mentioned after having entered C<perlbrew install>.

=head3 cpanm

Once your freshly-brewed Perl has been built and installed it's time to
install
L<cpanm|http://metacpan.org/pod/distribution/App-cpanminus/bin/cpanm> which
is a very handy program used to install Perl modules. To install C<cpanm>
simply run the following C<perlbrew> command:

    $ perlbrew install-cpanm

Running the command C<which cpanm> should now show C<cpanm> to be installed
inside your C<~/perl5/> directory:

    $ which cpanm
    <your-home-directory>/perl5/perlbrew/bin/cpanm

We're now ready to install Dancer2 and its dependencies!

=head3 Dancer2 installation

With lots of our supporting software in place, things just get easier and
easier. You can now install Dancer2 by simply running:

    $ cpanm Dancer2

=head3 Dancer2 dependencies

Lastly, we need to install the Perl modules which Dancer2 needs to use:

=over 4

=item Template Toolkit

The L<Template Toolkit|Template> is a set of Perl modules which collectively
implement a template processing system. We'll use this to reduce unnecessary
HTML coding in our micro blog.

=item File::Slurp

Simple and efficient reading, writing or modifying of complete files.

=item DBD::SQLite

The SQLite backend for the Perl database interface. This allows us to
interact with our SQLite installation directly from Perl.

=back

To install these dependencies, simply run this command:

    $ cpanm Template File::Slurp DBD::SQLite

Now we have all of the required software in place to create our app!

=head1 Create the Dancr project

Dancer2 comes with a command line interface: C<dancer2>. This program can be
used to create a new Dancer2 project. We could spend a lot of time setting
up directories and making sure we've got everything right, but it's I<much>
easier to use the helper program. Simply call C<dancer2> with the
C<--application> command line option (which specifies the name of the app to
be created):

    $ dancer2 --application Dancr
    + Dancr
    + Dancr/MANIFEST.SKIP
    + Dancr/Makefile.PL
    + Dancr/config.yml
    + Dancr/t
    + Dancr/t/002_index_route.t
    + Dancr/t/001_base.t
    + Dancr/lib
    + Dancr/lib/Dancr.pm
    + Dancr/public
    + Dancr/public/favicon.ico
    + Dancr/public/500.html
    + Dancr/public/dispatch.fcgi
    + Dancr/public/dispatch.cgi
    + Dancr/public/404.html
    + Dancr/public/javascripts
    + Dancr/public/javascripts/jquery.js
    + Dancr/public/css
    + Dancr/public/css/error.css
    + Dancr/public/css/style.css
    + Dancr/public/images
    + Dancr/public/images/perldancer.jpg
    + Dancr/public/images/perldancer-bg.jpg
    + Dancr/views
    + Dancr/views/index.tt
    + Dancr/views/layouts
    + Dancr/views/layouts/main.tt
    + Dancr/bin
    + Dancr/bin/app.pl
    + Dancr/environments
    + Dancr/environments/production.yml
    + Dancr/environments/development.yml

As the output shows, several directories and files have been automatically
created for us. We can see our app in action straight away, by simply
calling

    $ perl bin/app.pl

and then pointing a web browser at C<http://0.0.0.0:3000> (port 3000 on the
localhost).

We even have a test suite, which we can run like so:

    $ prove -lr t
    t/001_base.t ......... ok
    t/002_index_route.t .. 1/2 [Dancr:9068]  core @2014-10-09 11:55:51> looking for get / in .../Plack/Middleware/Head.pm l. 9
    [Dancr:9068]  core @2014-10-09 11:55:51> Entering hook core.app.before_request in .../Dancer2/Core/App.pm l. 1136
    [Dancr:9068]  core @2014-10-09 11:55:51> Entering hook core.app.after_request in .../Dancer2/Core/App.pm l. 1079
    t/002_index_route.t .. ok
    All tests successful.
    Files=2, Tests=3,  1 wallclock secs ( 0.02 usr  0.01 sys +  0.40 cusr  0.02 csys =  0.45 CPU)
    Result: PASS

And the tests pass! How cool is that?!

=head1 Our first Git commit

It'd be great to be able to save the current state of our project so that we
can return to it at some point in the future, if necessary. This is one of
the many great advantages of a version control system: it's possible to go
"back in time" to previous versions (and thus states) of a project, which
can be really handy if, for example, you've made an error and want to go
back to the last good version.

We'll now turn our C<Dancr/> directory into a Git repository (or simply
"repo", for short). Doing this in Git is very easy:

    $ git init
    Initialized empty Git repository in .../Dancr/.git/

That's it! Now we just need to add the files that the C<dancer2> command
created for us. This too, is really simple:

    $ git add .

Now Git knows to track the files in our C<Dancr/> project. To save the
current state of the repository, we need to I<commit> our changes (which in
our case was the addition of the project files). This we do like so:

    $ git commit -m "Initial import of Dancr project files"
    [master (root-commit) af8cc34] Initial import of Dancr project files
     22 files changed, 675 insertions(+)
     create mode 100644 MANIFEST
     create mode 100644 MANIFEST.SKIP
     create mode 100644 Makefile.PL
     create mode 100755 bin/app.pl
     create mode 100644 config.yml
     create mode 100644 environments/development.yml
     create mode 100644 environments/production.yml
     create mode 100644 lib/Dancr.pm
     create mode 100644 public/404.html
     create mode 100644 public/500.html
     create mode 100644 public/css/error.css
     create mode 100644 public/css/style.css
     create mode 100755 public/dispatch.cgi
     create mode 100755 public/dispatch.fcgi
     create mode 100644 public/favicon.ico
     create mode 100644 public/images/perldancer-bg.jpg
     create mode 100644 public/images/perldancer.jpg
     create mode 100644 public/javascripts/jquery.js
     create mode 100644 t/001_base.t
     create mode 100644 t/002_index_route.t
     create mode 100644 views/index.tt
     create mode 100644 views/layouts/main.tt

The C<-m> option to the C<git commit> command allows us to specify a commit
I<message> describing what the changes to the repository are. Make your
commit messages descriptive! You are writing a message to yourself in the
future, so be nice to your future self :-) If you ommit the C<-m> option,
then an editor will be automatically started for you to enter the commit
message. In most cases this is the best way to enter commit messages.

One can display old commit messages by using the C<git log> command. For
this project the log isn't particularly interesting (it contains only one
commit), however this is one of the fastest ways to see what has happened in
a project and to track down possible problems. Another good reason to make
your commit messages clear and descriptive!

=head1 The application we want to build

Ok, enough about Git, let's get back to creating our micro blog. In case you
don't know what a micro blog is, first, a quick explanation. Basically, this
is just like a normal blog, except you can only create entries with a title
and a short piece of text. In some ways very similar to Twitter except
without pictures (real micro blogs also allow pictures to be embedded,
however we're skipping that here to keep things a bit simpler).

So what components do we need to build such an application? Well, we'll need
a page where we can add new entries. This page will need a form in it with
elements to let you enter the title and text of a blog entry. The entries
will need to be stored somewhere, and a database is a logical and standard
place to do this. We'll also probably need to add login/logout functionality
so that we can stop unauthorized users from adding entries to our micro
blog. Do we need all of these components up front? No. Let's get something
running quickly by only implementing the form for adding blog entries.
Afterwards we can add a database (so that we can display old blog entries)
and then we can add authentication after that.

But first, let's scratch a little itch. Did you notice that our app is
currently called C<bin/app.pl>? Does that really describe the application
we're building? No. Hence, let's change its name to something a bit more
descriptive by using the C<git mv> (move/rename) command:

    $ git mv bin/app.pl bin/dancr.pl

Naturally this is also a change, so let's now commit that:

    $ git commit -m "Using a more descriptive name for main script"
    [master 721150e] Using a more descriptive name for main script
     1 file changed, 0 insertions(+), 0 deletions(-)
     rename bin/{app.pl => dancr.pl} (100%)

=head1 Creating the static application

In a separate terminal window, start the application by running

    $ perl bin/dancr.pl

and point your browser to C<http://0.0.0.0:3000>. We can keep this process
running while we're developing the web front end; it will help us see if the
changes we make are doing what we want.

Now open the main view template in a text editor C<views/index.tt> and
completely replace the file contents with the following HTML code:

     <h1>Dancr - a simple micro blog</h1>

     <form action="" method="post">
       <label>
         Title:
         <br>
         <input type="text" size="30" name="title">
       </label>
       <br>
       <label>
         Text:
         <br>
         <textarea name="text" rows="5" cols="40"></textarea>
       </label>
       <br>
       <input type="submit" value="Share">
     </form>

Just for those who might be wondering: why don't we add the C<< <html> >>,
C<< <body> >> etc. tags here? Well, this code is actually wrapped by such
code in the main layout file: C<views/layouts/main.tt>.

Now reload the page. You should see a very basic web page with some title
text, a text field for a blog entry title, a text field for its text and a
submit button. It's not pretty, but it's a beginning. The best thing about
it though is that it's I<working software> (it fulfils our initial
requirement of a simple web form). Our goal in this tutorial will be to have
working software the whole way through.

This is a good point to make a commit and save the current state:

    $ git add views/index.tt
    $ git commit -m "Replacing default index template with micro blog form"
    [master 9cac656] Replacing default index template with micro blog form
     1 file changed, 23 insertions(+), 147 deletions(-)
     rewrite views/index.tt (99%)

We also still have the dancer image as the background image to our page. We
also don't intend to use the standard dancer image in this project, so let's
remove them from our repository:

    $ git rm public/images/perldancer-bg.jpg
    rm 'public/images/perldancer-bg.jpg'
    $ git rm public/images/perldancer.jpg
    rm 'public/images/perldancer.jpg'
    $ git ci -m "Removing Perl Dancer images"
    [master a12a38c] Removing Perl Dancer images
     2 files changed, 0 insertions(+), 0 deletions(-)
     delete mode 100644 public/images/perldancer-bg.jpg
     delete mode 100644 public/images/perldancer.jpg

By the way, the C<public/> directory is where Dancer2 stores static files to
be served by the web server. That's why there are directories in here for
CSS, images and JavaScript.

=head1 The database

Ok, enough about Git, let's get back to creating our micro blog. We need to
set up our database to work with our application. To do this, we need to
create a database schema, and then connect the database to our application.

To create the schema, open your favorite L<text editor|http://www.vim.org>
and create a schema definition called C<schema.sql> with the following
content:

    create table if not exists entries (
	id integer primary key autoincrement,
	title string not null,
	text string not null
    );

Here we have a single table with three columns: id, title, and text.  The
'id' field is the primary key and will automatically get an ID assigned by
the database engine when a row is inserted.

That's worth a commit, so add the file

    $ git add schema.sql

and commit it:

    $ git commit -m "Adding database schema"

Our application file is currently called C<bin/app.pl> which isn't as
descriptive as it could be. Let's rename the file by using Git's C<mv>
(move) command:

    $ git mv bin/app.pl bin/dancr.pl

Ah, much better! This is a change to the repository and can be committed too:

    $ git commit -m "Renaming main application file"

=head2 Connecting to the database

We now want our application to initialize the database automatically for us when
we start it. We could just start writing code to make this work, however we
want to be I<absolutely sure> that the code is working properly, so first,
let's write tests to automatically check this behavior.

In the C<t/> directory you'll find two test files which were added as part
of project creation. We'll now add a third file, following the same file
name schema as the other two, calling it C<t/003_db.t>, since this will
contain tests of our database.  First add the boilerplate code to get things
going:

    use strict;
    use warnings;

    use Test::More tests => 1;

We're using the standard testing module L<Test::More>, which we tell that it
should expect this file to run one (and only one!) test. So what do we want
to test? Well, we need to make sure we can make a connection to the
database, so we want a function which connects to the database and returns a
handle to the database. We want to do something like this:

    my $db = connect_db();
    ok($db, "Database connection created");

where all we check for is that I<something> comes back from the
C<connect_db()> sub.

Running the tests with C<prove -lr t> shows that our test fails with the
error message:

    Undefined subroutine &main::connect_db called at t/003_db.t line 10.

which tells us that C<connect_db()> can't be found. This makes sense because
we haven't defined it yet. This is also the error that we were expecting, so
seeing this error is actually a good thing!

Notice that we have a C<lib/> directory within our project. Inside this
directory is where all our application code is meant to go. A
C<lib/Dancer.pm> file has already been created for us by C<dancer2> and it's
tempting to start to define the C<connect_db()> sub in this file, just
because it's available. However, the C<lib/Dancer.pm> file is where we want
the web-logic to go, and not where we want the database logic to go. Hence
we'll create a new file in a new subdirectory called C<lib/Dancr/DB.pm> and
make a module specific to our database needs. So, create the C<lib/Dancr/>
directory

    $ mkdir lib/Dancr

and create the C<lib/Dancr/DB.pm> file with the following code:

    package Dancr::DB;

    use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);

    use strict;
    use warnings;
    require Exporter;

    @ISA = qw(Exporter);
    @EXPORT_OK = qw();

    our $VERSION = '0.1';

    sub connect_db {
    }

    1;

Most of this code is just boilerplate in order to define the module. What's
important is the definition of the C<connect_db> sub. "But we just created
an empty sub!" I hear you saying. Well, yes, this is the point. The error
message was complaining about a missing subroutine, so we're creating it.
Remember that the trick is to write as little code as possible to get the
tests to work, and an empty subroutine definition is about as small as we
can get to solve the problem of an undefined subroutine.

Running the tests again, we find that the undefined subroutine error is
still there. Looking at the test code, we see that we've forgotten to import
the C<connect_db> sub into the namespace of our test. This is something we
should test: namely, can we import the subroutine successfully? Thus, we
update the number of tests to two:

    use Test::More tests => 2;

and add a test just before the database connection test to check that the
sub C<connect_db> can be imported:

    BEGIN { use_ok("Dancr::DB", qw(connect_db)); }

For details as to why you have to wrap this in a C<BEGIN> block, please see
the L<Test::More> documentation.

Running the tests shows us now that C<connect_db> isn't exported by the
C<Dancr::DB> module:

    $ prove -lr t
    <snip>
    t/003_db.t ........... 1/2
    #   Failed test 'use Dancr::DB;'
    #   at t/003_db.t line 6.
    #     Tried to use 'Dancr::DB'.
    #     Error:  "connect_db" is not exported by the Dancr::DB module
    # Can't continue after import errors at t/003_db.t line 6.

We can correct this by adding subroutine name to the C<@EXPORT_OK> array in
C<lib/Dancr/DB.pm>:

    @EXPORT_OK = qw(connect_db);

The tests now tell us that the database connection creation test failed:

    t/003_db.t ........... 1/2
    #   Failed test 'Database connection created'
    #   at t/003_db.t line 9.
    # Looks like you failed 1 test of 2.

which is the test that we wanted, yay!

Now let's write some I<real> code. Change the C<connect_db> code in
C<lib/Dancr/DB.pm> to this:

    use DBI;

    sub connect_db {
	my $dbh = DBI->connect("dbi:SQLite:dbname=dancr.db") or
	die $DBI::errstr;

	return $dbh;
    }

Running the tests now tells us that they all pass! This is awesome because
we have demonstrably I<working> software. This is also an appropriate time
for a commit and thus save the current state of the project. First add the
new files we've created:

    $ git add lib/Dancr/DB.pm t/003_db.t

and then commit them:

    $ git commit -m "Setting up the database connection"
    [master 957fe7e] Setting up the database connection
     2 files changed, 41 insertions(+)
     create mode 100644 lib/Dancr/DB.pm
     create mode 100644 t/003_db.t

The location of the database file isn't very flexible, though. It will
depend upon the directory from which we run the application, and that isn't
very good: we want to ensure that it has a well known, central location. A
reasonably good place for our project would be a C<db/> directory within the
the main project directory. After all, you might want to have multiple
database files, and you don't want to fill up the main project directory
with lots of files.

So let's write a test for that! Increase the number of tests to 3 in
C<t/003_db.t>, specify the name of the database file in a variable by using
a bit of a hack with the C<Cwd> module, remove the database file before the
test (just in case) and test that the database file exists after running
C<connect_db>. Hrm, that's quite a lot to describe, a diff is probably much
more explanatory:

    diff --git a/t/003_db.t b/t/003_db.t
    index 57f6b7d..041109b 100644
    --- a/t/003_db.t
    +++ b/t/003_db.t
    @@ -1,10 +1,18 @@
     use strict;
     use warnings;

    -use Test::More tests => 2;
    +use Test::More tests => 3;
    +use Cwd;

     BEGIN { use_ok("Dancr::DB", qw(connect_db)); }

    +my $cwd = getcwd();
    +my $dancr_db = $cwd . "/db/dancr.db";
    +
    +# clean up the database file in case it already exists
    +unlink $dancr_db if (-e $dancr_db);
    +
     my $db = connect_db();
     ok($db, "Database connection created");

    +ok(-e $dancr_db, "Database file created ($dancr_db)");

Running the tests shows us that the database file can't be created. This is
a Good Thing (TM), as this is the failure we expected. To solve this problem
we get to using the C<setting> feature of Dancer.



... at this point the wheels fall off ...



=head2 Initializing the database

    sub init_db {
        my $db = connect_db();
        my $schema = read_file('./schema.sql');
        $db->do($schema) or die $db->errstr;
    }

Nothing too fancy in here, I hope. Standard DBI except for the
C<setting('database')> thing - more on that in a bit.  For now, just assume
that the expression evaluates to the location of the database file.

(Note that you may want to look at the L<Dancer2::Plugin::Database> module
for an easy way to configure and manage database connections for your
Dancer2 apps, but the above will suffice for this tutorial.)


=head1 Our first route handler

Let's tackle our first route handler now, the one for the root URL '/'. This
is what it looks like:

  get '/' => sub {
    my $db = connect_db();
    my $sql = 'select id, title, text from entries order by id desc';
    my $sth = $db->prepare($sql) or die $db->errstr;
    $sth->execute or die $sth->errstr;
    template 'show_entries.tt', {
       'msg' => get_flash(),
       'add_entry_url' => uri_for('/add'),
       'entries' => $sth->fetchall_hashref('id'),
    };
  };

As you can see, the handler is created by specifying the HTTP verb 'get',
the '/' URL to match, and finally, a subroutine to do something once those
conditions have been satisfied.  Something you might not notice right away
is the semicolon at the end of the route handler.  Since the subroutine
is actually a coderef, it requires a semicolon.

Let's take a closer look at the subroutine.  The first few lines are
standard DBI. The only new concept as part of Dancer2 is that C<template>
directive at the end of the handler.  That tells Dancer2 to process the
output through one of its templating engines.  In this case, we're using
L<Template Toolkit|Template> which offers a lot more flexibility than the
simple default Dancer2 template engine.

Templates all go into the C<views/> directory. Optionally, you can create a
"layout" template which provides a consistent look and feel for all of your
views.  We'll construct our own layout template cleverly named F<main.tt> a
little later in this tutorial.

What's going on with the hashref as the second argument to the template
directive?  Those are all of the parameters we want to pass into our
template.  We have a C<msg> field which displays a message to the user when
an event happens like a new entry is posted, or the user logs in or out.
It's called a "flash" message because we only want to display it one time,
not every time the / URL is rendered.

The C<uri_for> directive tells Dancer2 to provide a URI for that specific
route, in this case, it is the route to post a new entry into the database.
You might ask why we don't simply hardcode the C</add> URI in our
application or templates.  The best reason B<not> to do that is because it
removes a layer of flexibility as to where to "mount" the web application.
Although the application is coded to use the root URL C</> it might be
better in the future to locate it under its own URL route (maybe C</dancr>?)
- at that point we'd have to go through our application and the templates
and update the URLs and hope we didn't miss any of them.  By using the
C<uri_for> Dancer2 method, we can easily load the application wherever we
like and not have to modify the application at all.

Finally, the C<entries> field contains a hashref with the results from our
database query.  Those results will be rendered in the template itself, so
we just pass them in.

So what does the F<show_entries.tt> template look like? This:

  [% IF session.logged_in %]
    <form action="[% add_entry_url %]" method=post class=add-entry>
      <dl>
        <dt>Title:
        <dd><input type=text size=30 name=title>
        <dt>Text:
        <dd><textarea name=text rows=5 cols=40></textarea>
        <dd><input type=submit value=Share>
      </dl>
    </form>
  [% END %]
  <ul class=entries>
  [% IF entries.size %]
    [% FOREACH id IN entries.keys.nsort %]
      <li><h2>[% entries.$id.title %]</h2>[% entries.$id.text %]
    [% END %]
  [% ELSE %]
    <li><em>Unbelievable.  No entries here so far</em>
  [% END %]
  </ul>

Again, since this isn't a tutorial specifically about Template Toolkit, I'm
going to gloss over the syntax here and just point out the section which
starts with C<E<lt>ul class=entriesE<gt>> - this is the section where the
database query results are displayed.  You can also see at the very top some
discussion about a session - more on that soon.

=head1 Other HTTP verbs

There are 8 defined HTTP verbs defined in L<RFC
2616|http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9>: OPTIONS,
GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT.  Of these, the majority of web
applications focus on the verbs which closely map to the CRUD (Create,
Retrieve, Update, Delete) operations most database-driven applications need
to implement.

In addition, the C<PATCH> verb was defined in
L<RFC5789|http://tools.ietf.org/html/rfc5789>, and is intended as a "partial
PUT" - sending just the changes required to the entity in question.  How
this would be handled is down to your app, it will vary depending on the
type of entity in question and the serialization in use.

Dancer2 currently supports GET, PUT/PATCH, POST, DELETE, OPTIONS which map
to Retrieve, Update, Create, Delete respectively.  Let's take a look now at
the C</add> route handler which handles a POST operation.

  post '/add' => sub {
     if ( not session('logged_in') ) {
        send_error("Not logged in", 401);
     }

     my $db = connect_db();
     my $sql = 'insert into entries (title, text) values (?, ?)';
     my $sth = $db->prepare($sql) or die $db->errstr;
     $sth->execute(params->{'title'}, params->{'text'}) or die $sth->errstr;

     set_flash('New entry posted!');
     redirect '/';
  };

As before, the HTTP verb begins the handler, followed by the route, and a
subroutine to do something - in this case, it will insert a new entry into
the database.

The first check in the subroutine is to make sure the user sending the data
is logged in. If not, the application returns an error and stops
processing.  Otherwise, we have standard DBI stuff. Let me insert (heh, heh)
a blatant plug here for always, always using parameterized INSERTs in your
application SQL statements.  It's the only way to be sure your application
won't be vulnerable to SQL injection. (See L<http://www.bobby-tables.com>
for correct INSERT examples in multiple languages.) Here we're using the
C<params> convenience method to pull in the parameters in the current HTTP
request. (You can see the 'title' and 'text' form parameters in the
F<show_entries.tt> template above.) Those values are inserted into the
database, then we set a flash message for the user and redirect her back to
the root URL.

It's worth mentioning that the "flash message" is not part of Dancer2, but a
part of this specific application.

=head1 Logins and sessions

Dancer2 comes with a simple in-memory session manager out of the box.  It
supports a bunch of other session engines including YAML, memcached, browser
cookies and others.  For this application we're going to stick with the
in-memory model which works great for development and tutorials, but won't
persist across server restarts or scale very well in "real world" production
scenarios.

=head2 Configuration options

To use sessions in our application, we have to tell Dancer2 to activate the
session handler and initialize a session manager.  To do that, we add some
configuration directives toward the top of our 'dancr.pl' file.  But there are
more options than just the session engine we want to set.

  set 'database'     => File::Spec->catfile(File::Spec->tmpdir(), 'dancr.db');
  set 'session'      => 'Simple';
  set 'template'     => 'template_toolkit';
  set 'logger'       => 'console';
  set 'log'          => 'debug';
  set 'show_errors'  => 1;
  set 'startup_info' => 1;
  set 'warnings'     => 1;

Hopefully these are fairly self-explanatory. We want the Simple session
engine, the Template Toolkit template engine, logging enabled (at the
'debug' level with output to the console instead of a file), we want to show
errors to the web browser, log access attempts and log Dancer2 warnings
(instead of silently ignoring them).

In a more sophisticated application you would want to put these
configuration options into a configuration file, but for this tutorial,
we're going to keep it simple.  Dancer2 also supports the notion of
application environments, meaning you can create a configuration file for
your development instance, and another config file for the production
environment (with things like debugging and showing errors disabled
perhaps). Dancer2 also doesn't impose any limits on what parameters you can
set using the C<set> syntax.  For this application we're going to embed our
single username and password into the application itself:

  set 'username' => 'admin';
  set 'password' => 'password';

Hopefully no one will ever guess our clever password!  Obviously, you will
want a more sophisticated user authentication scheme in any sort of
non-tutorial application but this is good enough for our purposes.

=head2 Logging in

Now that Dancr is configured to handle sessions, let's take a look at the
URL handler for the C</login> route.

  any ['get', 'post'] => '/login' => sub {
     my $err;

     if ( request->method() eq "POST" ) {
       # process form input
       if ( params->{'username'} ne setting('username') ) {
         $err = "Invalid username";
       }
       elsif ( params->{'password'} ne setting('password') ) {
         $err = "Invalid password";
       }
       else {
         session 'logged_in' => true;
         set_flash('You are logged in.');
         return redirect '/';
       }
    }

    # display login form
    template 'login.tt', {
      'err' => $err,
    };
  };

This is the first handler which accepts two different verb types, a GET for
a human browsing to the URL and a POST for the browser to submit the user's
input to the web application.  Since we're handling two different verbs, we
check to see what verb is in the request.  If it's B<not> a POST, we drop
down to the C<template> directive and display the F<login.tt> template:

  <h2>Login</h2>
  [% IF err %]<p class=error><strong>Error:</strong> [% err %][% END %]
  <form action="[% login_url %]" method=post>
    <dl>
      <dt>Username:
      <dd><input type=text name=username>
      <dt>Password:
      <dd><input type=password name=password>
      <dd><input type=submit value=Login>
    </dl>
  </form>

This is even simpler than our F<show_entries.tt> template - but wait -
there's a C<login_url> template parameter and we're only passing in the
C<err> parameter. Where's the missing parameter?  It's being generated and
sent to the template in a C<before_template> directive - we'll come back to
that in a moment or two.

So the user fills out the F<login.tt> template and submits it back to the
C</login> route handler.  We now check the user input against our
application settings and if the input is incorrect, we alert the user, otherwise
the application starts a session and sets the C<logged_in> session parameter
to the C<true()> value. Dancer2 exports both a C<true()> and C<false()>
convenience method which we use here.  After that, it's another flash
message and back to the root URL handler.

=head2 Logging out

And finally, we need a way to clear our user's session with the customary
logout procedure.

  get '/logout' => sub {
     app->destroy_session;
     set_flash('You are logged out.');
     redirect '/';
  };

C<app-E<gt>destroy_session;> is Dancer2's way to remove a stored session.
We notify the user she is logged out and route her back to the root URL once
again.

=head1 Layout and static files

We still have a missing puzzle piece or two.  First, how can we use Dancer2
to serve our CSS stylesheet? Second, where are flash messages displayed?
Third, what about the C<before_template> directive?

=head2 Serving static files

In Dancer2, static files should go into the C<public/> directory, but in the
application itself be sure to omit the C<public/> element from the path.  For
example, the stylesheet for Dancr lives in C<dancr/public/css/style.css> but
is served from L<http://localhost:3000/css/style.css>.

If you wanted to build a mostly static web site you could simply write route
handlers like this one:

  get '/' => sub {
     send_file 'index.html';
  };

where index.html would live in your C<public/> directory.

C<send_file> does exactly what it says: it loads a static file, then sends
the contents of that file to the user.

=head2 Layouts

I mentioned near the beginning of this tutorial that it is possible to
create a C<layout> template. In Dancr, that layout is called C<main> and
it's set up by putting in a directive like this:

  set layout => 'main';

near the top of your web application.  This tells Dancer2's template
engine that it should look for a file called F<main.tt> in
C<dancr/views/layouts/> and insert the calls from the C<template> directive
into a template parameter called C<content>.

For this web application, the layout template looks like this:

  <!doctype html>
  <html>
  <head>
    <title>Dancr</title>
    <link rel=stylesheet type=text/css href="[% css_url %]">
  </head>
  <body>
    <div class=page>
    <h1>Dancr</h1>
       <div class=metanav>
       [% IF not session.logged_in %]
         <a href="[% login_url %]">log in</a>
       [% ELSE %]
         <a href="[% logout_url %]">log out</a>
       [% END %]
    </div>
    [% IF msg %]
      <div class=flash> [% msg %] </div>
    [% END %]
    [% content %]
  </div>
  </body>
  </html>

Aha! You now see where the flash message C<msg> parameter gets rendered. You
can also see where the content from the specific route handlers is inserted
(the fourth line from the bottom in the C<content> template parameter).

But what about all those other C<*_url> template parameters?

=head2 Using C<before_template>

Dancer2 has a way to manipulate the template parameters before they're
passed to the engine for processing. It's C<before_template>.  Using this
directive, you can generate and set the URIs for the C</login> and
C</logout> route handlers and the URI for the stylesheet. This is handy for
situations like this where there are values which are re-used consistently
across all (or most) templates.  This cuts down on code-duplication and
makes your app easier to maintain over time since you only need to update
the values in this one place instead of everywhere you render a template.

  hook before_template => sub {
     my $tokens = shift;

     $tokens->{'css_url'} = request->base . 'css/style.css';
     $tokens->{'login_url'} = uri_for('/login');
     $tokens->{'logout_url'} = uri_for('/logout');
  };

Here again I'm using C<uri_for> instead of hardcoding the routes.  This code
block is executed before any of the templates are processed so that the
template parameters have the appropriate values before being rendered.

=head1 Putting it all together

Here's the complete 'dancr.pl' script from start to finish.

 use Dancer2;
 use DBI;
 use File::Spec;
 use File::Slurp;
 use Template;

 set 'database'     => File::Spec->catfile(File::Spec->tmpdir(), 'dancr.db');
 set 'session'      => 'Simple';
 set 'template'     => 'template_toolkit';
 set 'logger'       => 'console';
 set 'log'          => 'debug';
 set 'show_errors'  => 1;
 set 'startup_info' => 1;
 set 'warnings'     => 1;
 set 'username'     => 'admin';
 set 'password'     => 'password';
 set 'layout'       => 'main';

 my $flash;

 sub set_flash {
     my $message = shift;

     $flash = $message;
 }

 sub get_flash {

     my $msg = $flash;
     $flash = "";

     return $msg;
 }

 sub connect_db {
     my $dbh = DBI->connect("dbi:SQLite:dbname=".setting('database')) or
         die $DBI::errstr;

     return $dbh;
 }

 sub init_db {
     my $db = connect_db();
     my $schema = read_file('./schema.sql');
     $db->do($schema) or die $db->errstr;
 }

 hook before_template => sub {
     my $tokens = shift;

     $tokens->{'css_url'} = request->base . 'css/style.css';
     $tokens->{'login_url'} = uri_for('/login');
     $tokens->{'logout_url'} = uri_for('/logout');
 };

 get '/' => sub {
     my $db = connect_db();
     my $sql = 'select id, title, text from entries order by id desc';
     my $sth = $db->prepare($sql) or die $db->errstr;
     $sth->execute or die $sth->errstr;
     template 'show_entries.tt', {
         'msg' => get_flash(),
         'add_entry_url' => uri_for('/add'),
         'entries' => $sth->fetchall_hashref('id'),
     };
 };

 post '/add' => sub {
     if ( not session('logged_in') ) {
         send_error("Not logged in", 401);
     }

     my $db = connect_db();
     my $sql = 'insert into entries (title, text) values (?, ?)';
     my $sth = $db->prepare($sql) or die $db->errstr;
     $sth->execute(params->{'title'}, params->{'text'}) or die $sth->errstr;

     set_flash('New entry posted!');
     redirect '/';
 };

 any ['get', 'post'] => '/login' => sub {
     my $err;

     if ( request->method() eq "POST" ) {
         # process form input
         if ( params->{'username'} ne setting('username') ) {
             $err = "Invalid username";
         }
         elsif ( params->{'password'} ne setting('password') ) {
             $err = "Invalid password";
         }
         else {
             session 'logged_in' => true;
             set_flash('You are logged in.');
             return redirect '/';
         }
    }

    # display login form
    template 'login.tt', {
        'err' => $err,
    };

 };

 get '/logout' => sub {
    app->destroy_session;
    set_flash('You are logged out.');
    redirect '/';
 };

 init_db();
 start;

=head1 Advanced route moves

There's a lot more to route matching than shown here. For example, you can
match routes with regular expressions, or you can match pieces of a route
like C</hello/:name> where the C<:name> piece magically turns into a named
parameter in your handler for manipulation.

=head1 Happy dancing!

I hope this effort has been helpful and interesting enough to get you
exploring Dancer2 on your own. The framework is still under heavy
development but it's definitely mature enough to use in a production
project.  Additionally, there are now a lot of great Dancer2 plugins which
extend and enhance the capabilities of the platform.

Happy dancing!

=head1 SEE ALSO

=over 4

=item *

L<http://perldancer.org>

=item *

L<http://github.com/PerlDancer/Dancer2>

=item *

L<Dancer2::Plugins>

=back

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2010 by Mark R. Allen.

This is free software; you can redistribute it and/or modify it under the
terms of either the Artistic License 2.0 or the GNU Public License version
2.

The CSS stylesheet is copied verbatim from the Flaskr example application
and is subject to their license:

Copyright (c) 2010, 2013 by Armin Ronacher and contributors.

Some rights reserved.

Redistribution and use in source and binary forms of the software as well as
documentation, with or without modification, are permitted provided that the
following conditions are met:

=over 4

=item *

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

=item *

Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

=item *

The names of the contributors may not be used to endorse or promote products
derived from this software without specific prior written permission.

=back

=cut
